// @generated by protobuf-ts 2.9.6
// @generated from protobuf file "benchmark.proto" (syntax proto3)
// tslint:disable
import type {
    BinaryReadOptions,
    BinaryWriteOptions,
    IBinaryReader,
    IBinaryWriter,
    PartialMessage,
} from '@protobuf-ts/runtime';
import {
    MessageType,
    UnknownFieldHandler,
    WireType,
    reflectionMergePartial,
} from '@protobuf-ts/runtime';
/**
 * @generated from protobuf message TestMessage
 */
export interface TestMessage {
    /**
     * @generated from protobuf field: optional int32 int32 = 1;
     */
    int32?: number;
    /**
     * @generated from protobuf field: optional uint32 uint32 = 2;
     */
    uint32?: number;
    /**
     * @generated from protobuf field: optional sint32 sint32 = 3;
     */
    sint32?: number;
    /**
     * @generated from protobuf field: optional float float = 4;
     */
    float?: number;
    /**
     * @generated from protobuf field: optional double double = 5;
     */
    double?: number;
    /**
     * @generated from protobuf field: optional string string = 6;
     */
    string?: string;
    /**
     * @generated from protobuf field: repeated int32 repeatedInt32 = 7;
     */
    repeatedInt32: number[];
}
// @generated message type with reflection information, may provide speed optimized methods
class TestMessage$Type extends MessageType<TestMessage> {
    constructor() {
        super('TestMessage', [
            {
                no: 1,
                name: 'int32',
                kind: 'scalar',
                opt: true,
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 2,
                name: 'uint32',
                kind: 'scalar',
                opt: true,
                T: 13 /*ScalarType.UINT32*/,
            },
            {
                no: 3,
                name: 'sint32',
                kind: 'scalar',
                opt: true,
                T: 17 /*ScalarType.SINT32*/,
            },
            {
                no: 4,
                name: 'float',
                kind: 'scalar',
                opt: true,
                T: 2 /*ScalarType.FLOAT*/,
            },
            {
                no: 5,
                name: 'double',
                kind: 'scalar',
                opt: true,
                T: 1 /*ScalarType.DOUBLE*/,
            },
            {
                no: 6,
                name: 'string',
                kind: 'scalar',
                opt: true,
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 7,
                name: 'repeatedInt32',
                kind: 'scalar',
                repeat: 1 /*RepeatType.PACKED*/,
                T: 5 /*ScalarType.INT32*/,
            },
        ]);
    }
    create(value?: PartialMessage<TestMessage>): TestMessage {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.repeatedInt32 = [];
        if (value !== undefined) {
            reflectionMergePartial<TestMessage>(this, message, value);
        }
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TestMessage,
    ): TestMessage {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 int32 */ 1:
                    message.int32 = reader.int32();
                    break;
                case /* optional uint32 uint32 */ 2:
                    message.uint32 = reader.uint32();
                    break;
                case /* optional sint32 sint32 */ 3:
                    message.sint32 = reader.sint32();
                    break;
                case /* optional float float */ 4:
                    message.float = reader.float();
                    break;
                case /* optional double double */ 5:
                    message.double = reader.double();
                    break;
                case /* optional string string */ 6:
                    message.string = reader.string();
                    break;
                case /* repeated int32 repeatedInt32 */ 7:
                    if (wireType === WireType.LengthDelimited) {
                        for (
                            let e = reader.int32() + reader.pos;
                            reader.pos < e;

                        ) {
                            message.repeatedInt32.push(reader.int32());
                        }
                    } else {
                        message.repeatedInt32.push(reader.int32());
                    }
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw') {
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    }
                    let d = reader.skip(wireType);
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: TestMessage,
        writer: IBinaryWriter,
        options: BinaryWriteOptions,
    ): IBinaryWriter {
        /* optional int32 int32 = 1; */
        if (message.int32 !== undefined) {
            writer.tag(1, WireType.Varint).int32(message.int32);
        }
        /* optional uint32 uint32 = 2; */
        if (message.uint32 !== undefined) {
            writer.tag(2, WireType.Varint).uint32(message.uint32);
        }
        /* optional sint32 sint32 = 3; */
        if (message.sint32 !== undefined) {
            writer.tag(3, WireType.Varint).sint32(message.sint32);
        }
        /* optional float float = 4; */
        if (message.float !== undefined) {
            writer.tag(4, WireType.Bit32).float(message.float);
        }
        /* optional double double = 5; */
        if (message.double !== undefined) {
            writer.tag(5, WireType.Bit64).double(message.double);
        }
        /* optional string string = 6; */
        if (message.string !== undefined) {
            writer.tag(6, WireType.LengthDelimited).string(message.string);
        }
        /* repeated int32 repeatedInt32 = 7; */
        if (message.repeatedInt32.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.repeatedInt32.length; i++) {
                writer.int32(message.repeatedInt32[i]);
            }
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false) {
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer,
            );
        }
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TestMessage
 */
export const TestMessage = new TestMessage$Type();
